<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../pixi-js-component/pixi-js-component.html">
<link rel="import" href="../taaabs-time-utilities/taaabs-time-utilities.html">

<!--
`<taaabs-trace-timeline>` is a graphical elements that displays a timeline for a kTBS trace.

In typical use, just insert a `<taaabs-trace-timeline>`. Works with a `<taaabs-trace-timeline-scroller`.
Do not forget to bind their begin and end time.
-->
<dom-module id="taaabs-trace-timeline">
  <style>
     :host {
      display: block;
    }
     :host #pixijs {
      width: 1000px;
    }
  </style>
  <template>
    <pixi-js-component id="pixijs"></pixi-js-component>
  </template>
  <script>

    /**
     * Fired when the sleected obsel changes.
     *
     * @event selected-obsel
     */

    Polymer({
      is: 'taaabs-trace-timeline',

      properties: {

        /**
         * Begin time of the trace.
         *
         * @attribute begin
         * @type Number
         */
        begin: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * End time of the trace.
         *
         * @attribute end
         * @type Number
         */
        end: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * True, uses an OpenGL renderer.
         * False, uses a simple canvas.
         *
         * @attribute openGl
         * @type Boolean
         */
        openGl: {
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * A selected obsel (highlight).
         *
         * @attribute selectedObsel
         * @type Object
         */
        selectedObsel: {
         type: Object,
         value: null
        },

        /**
         * (PIXI.Container) Main container of the `_backgroundContainers`.
         *
         * @attribute _backgroundContainer
         * @type Object
         */
        _backgroundContainer: {
         type: Object,
         value: null
        },

        /**
         * List of the background containers (PIXI.Container).
         *
         * @attribute _backgroundContainers
         * @type Array
         */
        _backgroundContainers: {
         type: Array,
         value: []
        },

        /**
         * (PIXI.Container) The main container of the `_obselsContainers`.
         *
         * @attribute _obselsContainer
         * @type Object
         */
        _obselsContainer: {
         type: Object,
         value: null
        },

        /**
         * List of PIXI.Container that represent a pile of obsels on the timeline.
         *
         * @attribute _obselsContainers
         * @type Array
         */
        _obselsContainers: {
          type: Array,
          value: []
        },

        /**
         * Width of an obsel graphic representation (PIXI.Graphics).
         *
         * @attribute _obselWidth
         * @type Number
         */
        _obselWidth: {
          type: Number,
          value: 14
        },

        /**
         * (PIXI.Container) Main container of the `_selectContainers`.
         *
         * @attribute _selectContainer
         * @type Object
         */
        _selectContainer: {
         type: Object,
         value: null
        },

        /**
         * List of the select containers.
         *
         * @attribute _selectContainers
         * @type Array
         */
        _selectContainers: {
         type: Array,
         value: []
        },

        /**
         * TaaabsTimeUtilities.
         *
         * @attribute _ttu
         * @type Number
         */
        _ttu: {
          type: Object,
          notify: true,
          value: function(){
            return new TaaabsTimeUtilities();
          }
        },

        /**
         * Width of the pixijs component.
         *
         * @attribute _width
         * @type Number
         */
        _width: {
          type: Number,
          notify: true,
          value: 0
        }
      },

      listeners: {},

      ready: function() {},

      /**
       * Add some obsels to the timeline. Calls `_createObsel`.
       *
       * @param {!required} list (Array) A list of obsels to display.
       *
       * @method addObsels
       */
      addObsels: function(list) {
        var cIndex = 0;
        var oIndex = 0;
        var overflow = 0;
        // For each obsel pile, check if its not full, then draw the obsel.
        for (cIndex = 0; cIndex < this._obselsContainers.length; cIndex++) {
          overflow = 0;
          while (oIndex < list.length && this._obselsContainers[cIndex].b <= list[oIndex].obsel.begin && this._obselsContainers[cIndex].e > list[oIndex].obsel.end) {
            if (this._obselsContainers[cIndex].c.children.length < 20){
              this._obselsContainers[cIndex].c.addChild(this._createObsel(cIndex, list[oIndex]));
            }
            else{
              overflow ++;
            }
            oIndex++;
          }
          if(this._obselsContainers[cIndex].of > 0 && overflow > 0){
            this._obselsContainers[cIndex].c.removeChildAt(this._obselsContainers[cIndex].c.children.length - 1);
          }
          this._manageObselContainerOverflow(this._obselsContainers[cIndex], overflow);
        }
      },

      /**
       * Initialize the visualization.
       *
       * @method initVisu
       */
      initVisu: function() {
        // Set the pixijs component
        this.set('_width', 1400);
        this.$.pixijs.set('width', 1400);
        this.$.pixijs.set('height', this._getHeight());
        this.$.pixijs.init({
          antialias: false,
          backgroundColor: 0xFAFAFA
        });
        // Listen to pixi resize. TODO: manage iron-resize
        //this.listen(this.$.pixijs, 'iron-resize', '_onPixiJsResize');
        //this.set('_width', this.$.pixijs.clientWidth);
        // Initialize the keyboard behavior
        this._initKeyboard();
      },

      /**
       * This function aims to calibrate the timeline on new begin/end timestamps.
       * Set the begin & end of the `taaabs-trace-timeline`.
       * Calls `_initBackgroundContainer`, `_initObselsContainer` & `_initSelectContainer`.
       *
       * @param {!required} begin (Number) The begin timestamp.
       * @param {!required} end   (Number) The end timestamp.
       *
       * @method setTemporalBounds
       */
      setTemporalBounds: function(begin, end){
        this.set('begin', begin);
        this.set('end', end);
        // Clear the timeline
        this.$.pixijs.clearStage();
        // Init everything
        this._initBackgroundContainer();
        this._initObselsContainer();
        this._initSelectContainer();
      },

      /**
       * Shift the obsels one column to the left or the right.
       *
       * @param {!required} new_obsels {String} List of the new obsels to display.
       *
       * @param {!required} direction {String} Left or right.
       *
       * @method shiftObsels
       */
      shiftObsels: function(new_obsels, direction) {
        if(direction === 'left'){
          this._obselsContainer.removeChildAt(0);
          this._obselsContainers.splice(0,1);
          for(var i = 0; i < this._obselsContainers.length; i++){
            this._obselsContainers[i].c.x -= ( this._obselWidth + 2 );
            this._obselsContainers[i]._intervalIndex = i;
          }
          var container = this._createContainer(this._obselsContainers.length);
          var period = this._obselsContainers[0].e - this._obselsContainers[0].b;
          var b = this._obselsContainers[this._obselsContainers.length - 1].e + 1;
          var e = b + period;
          this.push('_obselsContainers', {
            "c": container,
            "b": b,
            "e": e,
            "of": 0
          });
          this._obselsContainer.addChild(this._obselsContainers[this._obselsContainers.length - 1].c);
          this.addObsels(new_obsels);
        }
        else{
          this._obselsContainer.removeChildAt(this._obselsContainer.children.length - 1);
          this.splice('_obselsContainers', this._obselsContainers.length - 1, 1);
          for(var i = 0; i < this._obselsContainers.length; i++){
            this._obselsContainers[i].c.x += ( this._obselWidth + 2 );
            this._obselsContainers[i]._intervalIndex = i + 1;
          }
          var container = this._createContainer(0);
          var period = this._obselsContainers[0].e - this._obselsContainers[0].b;
          var e = this._obselsContainers[0].b - 1;
          var b = e - period;
          this.splice('_obselsContainers',0,0, {
            "c": container,
            "b": b,
            "e": e,
            "of": 0
          });
          this._obselsContainer.addChildAt(this._obselsContainers[0].c,0);
          this.addObsels(new_obsels);
        }
      },

      /**
       * Create an obsel container at a given index (position).
       *
       * @method _createContainer
       */
      _createContainer: function(index) {
        var container = new PIXI.Container();
        container.x = (this._obselWidth + 2) * index;
        container.y = 0;
        container.width = (this._obselWidth + 2);
        container.height = 215;
        container._intervalIndex = index;
        return container;
      },

      /**
       * Create an obsel graphic element. Set its behavior on mouse events.
       * TODO: Finish shape set.
       *
       * @param {!required} cIndex (Number) The index of the container that contains the obsel.
       * @param {!required} obsel (Obsel)   The obsel to display.
       *
       * @method _createObsel
       */
      _createObsel: function(cIndex, obsel) {
        var o = new PIXI.Graphics();
        var y = (20 * (this._obselWidth + 1)) - ((this._obselWidth + 1) * this._obselsContainers[cIndex].c.children.length);
        o.beginFill(parseInt(obsel.symbol.color.replace('#',''), 16));
        o.drawCircle((this._obselWidth + 2) / 2, (this._obselWidth + 2) / 2, this._obselWidth / 2);
        o.endFill();
        o.y = y;
        o.x = 1;
        o.originalColor = parseInt(obsel.symbol.color.replace('#',''), 16);
        // Set interactivity
        o.interactive = true;
        o.buttonMode = true;
        o.obsel = obsel.obsel;
        o._cIndex = cIndex;
        o._oIndex = this._obselsContainers[cIndex].c.children.length;

        o.on('mouseover', function(component, evt) {
          component._highlightObsel(this);
        }.bind(o, this));

        o.on('mouseout', function(component, evt) {
          if (!this._selected) {
            component._resetObsel(this);
          }
        }.bind(o, this));

        o.on('mouseup', function(component, evt) {
          this._selected = true;
          if(component.selectedObsel){
            component.selectedObsel._selected = false;
            component._resetObsel(component.selectedObsel);
          }
          component._highlightObsel(this);
          component.set('selectedObsel', this);
          component.fire('selected-obsel');
        }.bind(o, this));
        return o;
      },

      /**
       * Fill the background containers with one of the two colors.
       * A background container aims to represents to which time interval a pile of obsel belongs.
       *
       * @method _fillBackgroundContainers
       */
      _fillBackgroundContainers: function(){
        // Retrieve the fitest period.
        var p = this._ttu.get_fittest_period(this.begin, this.end, 20);
        var colors = [0xECEFF1, 0xFAFAFA];
        var color = 1;
        // We set the variables
        var b = this.begin;
        var e = this.end;
        var d = new Date(b);
        d = this._ttu.get_date_according_to_period(p, d);
        // We reset the _ttu repeater
        this._ttu.set('beginDate', d);
        this._ttu.set('interval', p);
        this._ttu.resetIntervalRepeater();
        // Result will define the bounds of every interval we create.
        var result = {
          'begin': d,
          'end': d
        };
        var intervals = [];
        var cIndex = 0;
        // We create the intervals in a loop until we reach the end of the trace.
        while (result.end.valueOf() < e) {
          result = this._ttu.getNextIntervalUTC(null);
          color = (color === 1) ? 0 : 1;
          while(cIndex < this._backgroundContainers.length && this._backgroundContainers[cIndex].b >= result.begin.valueOf() && this._backgroundContainers[cIndex].e <= result.end.valueOf()){
            var o = new PIXI.Graphics();
            o.beginFill(colors[color]);
            o.drawRect(0, 0, this._obselWidth + 2, 415);
            o.endFill();
            o.y = 0;
            o.x = 0;

            this._backgroundContainers[cIndex].c.addChild(o);
            cIndex++;
          }
          if(cIndex < this._backgroundContainers.length && this._backgroundContainers[cIndex].e > result.end.valueOf()){
            var b1 = this._backgroundContainers[cIndex].b;
            var e1 = this._backgroundContainers[cIndex].e;
            var b2 = result.begin;
            var e2 = result.end;
            var h = (e1 - e2)/(e1 - b1) * 315;
            var pcolor = (color === 0) ? 1 : 0;
            var o = new PIXI.Graphics();
            o.beginFill(colors[pcolor]);
            o.drawRect(0, 0, this._obselWidth + 2, h);
            o.endFill();
            o.y = 0;
            o.x = 0;
            this._backgroundContainers[cIndex].c.addChild(o);
            o = new PIXI.Graphics();
            o.beginFill(colors[color]);
            o.drawRect(0, 0, this._obselWidth + 2, 315 - h);
            o.endFill();
            o.y = h;
            o.x = 0;
            this._backgroundContainers[cIndex].c.addChild(o);
            cIndex++;
          }
        }
      },

      /**
       * Fill a selected sub-container. Basically draw a blue rectangle in it.
       *
       * @param {!required} container (PIXI.Container) A selected sub-container.
       *
       * @method _fillSelectedContainer
       */
      _fillSelectedContainer: function(container){
        if(container.children.length === 0){
          var g = new PIXI.Graphics();
          g.beginFill(0x039BE5);
          g.drawRect(0, 0, this._obselWidth + 2, 315);
          g.alpha = 0.37;
          g.endFill();
          g.x = 0;
          g.y = 0;
          container.addChild(g);
        }
      },

      /**
       * Return the complementary color of a color in hexadecimal format.
       *
       * @param {!required} hex (Number) A color in hexadecimal number (0xFFFFFF for example).
       *
       * @method _getComplementaryColor
       */
      _getComplementaryColor: function(hex) {
        temprgb = hexToRgb(hex);
        temphsv = RGB2HSV(temprgb);
        temphsv.hue = HueShift(temphsv.hue, 180.0);
        temprgb = HSV2RGB(temphsv);
        return rgbToHex(temprgb);

        function componentToHex(c) {
          var hex = c.toString(16);
          return hex.length == 1 ? "0" + hex : hex;
        }

        function rgbToHex(rgb) {
          return parseInt(componentToHex(rgb.r) + componentToHex(rgb.g) + componentToHex(rgb.b), 16);
        }

        function hexToRgb(hex) {
          var shex = hex.toString(16);
          return {
            "r": parseInt(shex.substr(0, 2), 16),
            "g": parseInt(shex.substr(2, 2), 16),
            "b": parseInt(shex.substr(4, 2), 16),
          };
        }

        function RGB2HSV(rgb) {
          hsv = new Object();
          max = max3(rgb.r, rgb.g, rgb.b);
          dif = max - min3(rgb.r, rgb.g, rgb.b);
          hsv.saturation = (max == 0.0) ? 0 : (100 * dif / max);
          if (hsv.saturation == 0) hsv.hue = 0;
          else if (rgb.r == max) hsv.hue = 60.0 * (rgb.g - rgb.b) / dif;
          else if (rgb.g == max) hsv.hue = 120.0 + 60.0 * (rgb.b - rgb.r) / dif;
          else if (rgb.b == max) hsv.hue = 240.0 + 60.0 * (rgb.r - rgb.g) / dif;
          if (hsv.hue < 0.0) hsv.hue += 360.0;
          hsv.value = Math.round(max * 100 / 255);
          hsv.hue = Math.round(hsv.hue);
          hsv.saturation = Math.round(hsv.saturation);
          return hsv;
        }

        // RGB2HSV and HSV2RGB are based on Color Match Remix [http://color.twysted.net/]
        // which is based on or copied from ColorMatch 5K [http://colormatch.dk/]
        function HSV2RGB(hsv) {
          var rgb = new Object();
          if (hsv.saturation == 0) {
            rgb.r = rgb.g = rgb.b = Math.round(hsv.value * 2.55);
          } else {
            hsv.hue /= 60;
            hsv.saturation /= 100;
            hsv.value /= 100;
            i = Math.floor(hsv.hue);
            f = hsv.hue - i;
            p = hsv.value * (1 - hsv.saturation);
            q = hsv.value * (1 - hsv.saturation * f);
            t = hsv.value * (1 - hsv.saturation * (1 - f));
            switch (i) {
              case 0:
                rgb.r = hsv.value;
                rgb.g = t;
                rgb.b = p;
                break;
              case 1:
                rgb.r = q;
                rgb.g = hsv.value;
                rgb.b = p;
                break;
              case 2:
                rgb.r = p;
                rgb.g = hsv.value;
                rgb.b = t;
                break;
              case 3:
                rgb.r = p;
                rgb.g = q;
                rgb.b = hsv.value;
                break;
              case 4:
                rgb.r = t;
                rgb.g = p;
                rgb.b = hsv.value;
                break;
              default:
                rgb.r = hsv.value;
                rgb.g = p;
                rgb.b = q;
            }
            rgb.r = Math.round(rgb.r * 255);
            rgb.g = Math.round(rgb.g * 255);
            rgb.b = Math.round(rgb.b * 255);
          }
          return rgb;
        }

        //Adding HueShift via Jacob (see comments)
        function HueShift(h, s) {
          h += s;
          while (h >= 360.0) h -= 360.0;
          while (h < 0.0) h += 360.0;
          return h;
        }

        //min max via Hairgami_Master (see comments)
        function min3(a, b, c) {
          return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);
        }

        function max3(a, b, c) {
          return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);
        }
      },

      /**
       * Return the width of the pixijs component (in pixels).
       *
       * @method _getWidth
       */
      _getWidth: function() {
        return this._width;
      },

      /**
       * Return the height of the visu.
       *
       * @method _getHeight
       */
      _getHeight: function() {
        return 315;
      },

      /**
       * Add an outline at an obsel graphic.
       *
       * @param {!required} o (PIXI.Graphics) An obsel graphic representation.
       *
       * @method _highlightObsel
       */
      _highlightObsel: function(o) {
        o.clear();
        o.beginFill(o.originalColor);
        o.lineStyle(4, this._getComplementaryColor(o.originalColor), 1);
        o.drawCircle((this._obselWidth + 2) / 2, (this._obselWidth + 2) / 2, this._obselWidth / 2);
        o.endFill();
      },

      /**
       * Init the background containers. Those containers represent a time interval (month, week, etc.).
       * Calls `_fillBackgroundContainers`.
       *
       * @method _initBackgroundContainer
       */
      _initBackgroundContainer: function(){
        // If the background container already exists, we delete it.
        if(this._backgroundContainer){
          this.$.pixijs.removeChildFromStage(this._backgroundContainer);
        }
        // Create & set the background main container.
        this.set('_backgroundContainer', new PIXI.Container());
        this._backgroundContainer.x = 0;
        this._backgroundContainer.y = 0;
        this._backgroundContainer.width = this._width;
        this._backgroundContainer.height = 315;
        // Calculate the subdivisions of the background container.
        var contCount = this._width / (this._obselWidth + 2);
        var duration = this.end - this.begin;
        var period = Math.ceil(duration / contCount);
        this.set('_backgroundContainers', []);
        // Create each abckground containers.
        for (var i = 0; i < contCount; i++) {
          var b = this.begin + (period * i);
          var e = b + period;
          var container = this._createContainer(i);
          this.push('_backgroundContainers', {
            "c": container,
            "b": b,
            "e": e
          });
          this._backgroundContainer.addChild(container);
        }
        this.$.pixijs.addToStage(this._backgroundContainer);
        // Fill the backgrounds containers with one of the two colors.
        this._fillBackgroundContainers();
      },

      /**
       * Init the keyboard listeners to set the behavior on arrow keys.
       * The user will be allowed to move in the timeline using the arrow keys.
       *
       * @method _initKeyboard
       */
      _initKeyboard: function() {
        // Set the keyboard listeners.
        var left = this._keyboard(37),
          up = this._keyboard(38),
          right = this._keyboard(39),
          down = this._keyboard(40);
        // Up behavior
        up.press = function() {
          if(this.selectedObsel){
            var oIndex = this.selectedObsel._oIndex;
            var cIndex = this.selectedObsel._cIndex;
            if(oIndex + 1 < this._obselsContainers[cIndex].c.children.length){
              var no = this._obselsContainers[cIndex].c.getChildAt(oIndex + 1);
              this._highlightObsel(no);
              this._resetObsel(this.selectedObsel);
              no._selected = true;
              this.selectedObsel._selected = false;
              this.set('selectedObsel' , no);
              this.set('_lastObselIndex', oIndex + 1);
              this.fire('selected-obsel');
            }
            else{
              cIndex++;
              while(cIndex < this._obselsContainers.length && this._obselsContainers[cIndex].c.children.length === 0){
                cIndex++;
              }
              if(cIndex < this._obselsContainers.length){
                var no = this._obselsContainers[cIndex].c.getChildAt(0);
                this._highlightObsel(no);
                this._resetObsel(this.selectedObsel);
                no._selected = true;
                this.selectedObsel._selected = false;
                this.set('selectedObsel' , no);
                this.set('_lastObselIndex', 0);
                this.fire('selected-obsel');
              }
            }
          }
        }.bind(this);

        down.press = function() {
          if(this.selectedObsel){
            var oIndex = this.selectedObsel._oIndex;
            var cIndex = this.selectedObsel._cIndex;
            if(oIndex - 1 >= 0){
              var no = this._obselsContainers[cIndex].c.getChildAt(oIndex - 1);
              this._highlightObsel(no);
              this._resetObsel(this.selectedObsel);
              no._selected = true;
              this.selectedObsel._selected = false;
              this.set('selectedObsel', no);
              this.set('_lastObselIndex', oIndex - 1);
              this.fire('selected-obsel');
            }
            else{
              cIndex--;
              while(cIndex >= 0 && this._obselsContainers[cIndex].c.children.length === 0){
                cIndex--;
              }
              if(cIndex >= 0){
                var no = this._obselsContainers[cIndex].c.getChildAt(this._obselsContainers[cIndex].c.children.length - 1);
                this._highlightObsel(no);
                this._resetObsel(this.selectedObsel);
                no._selected = true;
                this.selectedObsel._selected = false;
                this.set('selectedObsel', no);
                this.set('_lastObselIndex', this._obselsContainers[cIndex].c.children.length - 1);
                this.fire('selected-obsel');
              }
            }
          }
        }.bind(this);

        right.press = function() {
          if(this.selectedObsel){
            var oIndex = this.selectedObsel._oIndex;
            var cIndex = this.selectedObsel._cIndex;
            cIndex++;
            while(cIndex < this._obselsContainers.length && this._obselsContainers[cIndex].c.children.length === 0){
              cIndex++;
            }
            if(cIndex < this._obselsContainers.length){
              var no;
              if( this._lastObselIndex < this._obselsContainers[cIndex].c.children.length){
                no = this._obselsContainers[cIndex].c.getChildAt(this._lastObselIndex);
              }
              else{
                no = this._obselsContainers[cIndex].c.getChildAt(this._obselsContainers[cIndex].c.children.length - 1);
              }
              this._highlightObsel(no);
              this._resetObsel(this.selectedObsel);
              no._selected = true;
              this.selectedObsel._selected = false;
              this.set('selectedObsel', no);
              this.fire('selected-obsel');
            }
          }
        }.bind(this);

        left.press = function() {
          if(this.selectedObsel){
            var oIndex = this.selectedObsel._oIndex;
            var cIndex = this.selectedObsel._cIndex;
            cIndex--;
            while(cIndex >= 0 && this._obselsContainers[cIndex].c.children.length === 0){
              cIndex--;
            }
            if(cIndex >= 0){
              var no;
              if( this._lastObselIndex < this._obselsContainers[cIndex].c.children.length){
                no = this._obselsContainers[cIndex].c.getChildAt(this._lastObselIndex);
              }
              else{
                no = this._obselsContainers[cIndex].c.getChildAt(this._obselsContainers[cIndex].c.children.length - 1);
              }
              this._highlightObsel(no);
              this._resetObsel(this.selectedObsel);
              no._selected = true;
              this.selectedObsel._selected = false;
              this.set('selectedObsel', no);
              this.fire('selected-obsel');
            }
          }
        }.bind(this);
      },

      /**
       * Init the obsels containers. An obsel container is a pile of obsel of a given interval.
       *
       * @method _initObselsContainer
       */
      _initObselsContainer: function() {
        // TODO clean before.
        if(this._obselsContainer){
          this.$.pixijs.removeChildFromStage(this._obselsContainer);
        }
        // Create the obsels main container.
        this.set('_obselsContainer', new PIXI.Container());
        this._obselsContainer.x = 0;
        this._obselsContainer.y = 0;
        this._obselsContainer.width = this._width;
        this._obselsContainer.height = 315;
        // Calculate the intervals and create the sub-containers.
        var contCount = this._width / (this._obselWidth + 2);
        var duration = this.end - this.begin;
        var period = Math.ceil(duration / contCount);
        this.set('_obselsContainers', []);
        for (var i = 0; i < contCount; i++) {
          var b = this.begin + (period * i);
          var e = b + period
          var container = this._createContainer(i);
          this.push('_obselsContainers', {
            "c": container,
            "b": b,
            "e": e,
            "of": 0
          });
          this._obselsContainer.addChild(container);
        }
        this.$.pixijs.addToStage(this._obselsContainer);
      },

      /**
       * Initialize the selection containers. Those containers allow the user to select a zone on the timeline,
       * in order to zoom.
       *
       * @method _initSelectContainer
       */
      _initSelectContainer: function(){
        // If there already is a select container, delete it.
        if(this._selectContainer){
          this.$.pixijs.removeChildFromStage(this._selectContainer);
        }
        // Create and set the main container.
        this.set('_selectContainer', new PIXI.Container());
        this._selectContainer.x = 0;
        this._selectContainer.y = 0;
        this._selectContainer.width = this._width;
        this._selectContainer.height = 315;
        // Divide the timeline in n sub container of the size of one obsel symbol.
        // In this way, we'll select a pile of obsel one at a time.
        var contCount = this._width / (this._obselWidth + 2);
        var duration = this.end - this.begin;
        var period = Math.ceil(duration / contCount);
        this.set('_selectContainers', []);
        // Create all the select sub-containers.
        for (var i = 0; i < contCount; i++) {
          var b = this.begin + (period * i);
          var e = b + period;
          var container = this._createContainer(i);
          container = this._setSelectContainerBehavior(container);
          this.push('_selectContainers', {
            "c": container,
            "b": b,
            "e": e
          });
          this._selectContainer.addChild(container);
        }
        this.$.pixijs.addToStage(this._selectContainer);
      },

      /**
       * TODO: Complete. Is supposed to fire event ...
       *
       * @param {!required} list (Array) List of selected pile of obsel.
       *
       * @method _intervalSelectSelected
       */
      _intervalSelectSelected: function(list){
        var b = this._selectContainers[this._startSelectSelectedIndex].b;
        var e = this._selectContainers[this._endSelectSelectedIndex].e;
        this.fire('timeline-interval-selected', {
          'b': b,
          'e': e
        })
      },

      /**
       * Set the behavior on a certain key down/up.
       *
       * @param {!required} keyCode (Number) The key code.
       *
       * @method _keyboard
       */
      _keyboard: function(keyCode) {
        var key = {};
        key.code = keyCode;
        key.isDown = false;
        key.isUp = true;
        key.press = undefined;
        key.release = undefined;
        //The `downHandler`
        key.downHandler = function(event) {
          if (event.keyCode === key.code) {
            if (key.isUp && key.press) key.press();
            key.isDown = true;
            key.isUp = false;
            event.preventDefault();
          }
        };
        //The `upHandler`
        key.upHandler = function(event) {
          if (event.keyCode === key.code) {
            if (key.isDown && key.release) key.release();
            key.isDown = false;
            key.isUp = true;
            event.preventDefault();
          }
        };
        //Attach event listeners
        window.addEventListener(
          "keydown", key.downHandler.bind(key), false
        );
        window.addEventListener(
          "keyup", key.upHandler.bind(key), false
        );
        return key;
      },

      /**
       * Display, if necessary, the obsel obsels overflow on the container.
       *
       * @param {!required} container (PIXI.Container) The obsel container.
       * @param {!required} overflow  (Number) The obsels overflow.
       *
       * @method _manageObselContainerOverflow
       */
      _manageObselContainerOverflow: function(container, overflow) {
        if(overflow > 0){
          overflow += container.of;
          // TODO Use a var !
          if(container.c.children.length === 20){
            container.c.removeChildAt(container.c.children.length - 1);
            overflow += 1;
          }
          // Add the text
          container.of = overflow;
          var t = new PIXI.Text("+"+overflow,{
            fontFamily: "Arial",
            fontSize: this._obselWidth,
            fill: 0x000000,
            align: "right"
          });
          t.anchor.set(0.5);
          t.setTransform(null,null,null,null,-1.5708);
          t.y = ( t.width / 2 ) + 2;
          t.x = ( t.height / 2 ) + 1;
          // Remove the two last obsels and add the counter
          container.c.addChild(t);
        }
        else{
          container.of = 0;
        }
      },

      /**
       * Change `_width` according to the pixi width.
       *
       * @method _onPixiJsResize
       */
      _onPixiJsResize: function() {
        console.log('resize?');
        this.async(function(evt) {
          this.set('_width', this.$.pixijs.clientWidth);
          this.updateVisu();
        }.bind(this), 500);
      },

      /**
       * Reset the outline of an obsel graphic representation.
       *
       * @param {!required} o (PIXI.Graphics) An obsel graphic representation.
       *
       * @method _resetObsel
       */
      _resetObsel: function(o) {
        o.clear();
        o.beginFill(o.originalColor);
        o.drawCircle((this._obselWidth + 2) / 2, (this._obselWidth + 2) / 2, this._obselWidth / 2);
        o.endFill();
      },

      /**
       * Set the behavior of a select sub-container (i.e  mouseover, mouseup, etc).
       * Returns the container set.
       *
       * @param {!required} container (PIXI.Container) A select sub-container.
       *
       * @method _setSelectContainerBehavior
       */
      _setSelectContainerBehavior: function(container){
        // Set the container interactive.
        container.interactive = true;
        container.hitArea = new PIXI.Rectangle(0, 0, this._obselWidth + 2, 315);
        // On mouse over :
        // I.   _lastHoverSelectIndex <- the tile index & _lastHoverTime -> Date.now()
        //
        // II.  If _isBeingSelected, set in onMouseDown & onMouseUp & onMouseUpOutside
        //   .1.  We fill all the selecting tile with blue, selected tile with light-blue & reste with black.
        //
        // III. If we're not selecting any tile, and if the tile is not selected, with hightlight it.
        container.on('mouseover', function(component, evt) {
          // I.
          component.set('_lastHoverSelectIndex', this._intervalIndex);
          component.set('_lastHoverTime'     , Date.now());
          // II.
          if(component._isBeingSelected){
            var s = component._startSelectSelectedIndex;
            var e = this._intervalIndex;
            // If the user selected from right to left, we invert indexes.
            if(s > e){
              s = e;
              e = component._startSelectSelectedIndex;
            }
            // For each tile, we fill witht he right color
            var l = component._selectContainers;
            for(var i = 0; i < l.length; i++){
              if     ( i >= s && i <= e) { component._fillSelectedContainer(l[i].c); }
              else                       { l[i].c.removeChildren();   }
            }
          }
        }.bind(container, this));

        // On mouse out :
        // I.   _lastLeaveSelectIndex <- the tile index & _lastLeaveTime -> Date.now()
        container.on('mouseout', function(component, evt) {
          // I.
          component.set('_lastLeaveSelectIndex', this._intervalIndex);
          component.set('_lastLeaveTime', Date.now());
        }.bind(container, this));

        // On mouse down :
        // I. _isBeingSelected <- true; _startSelectSelectedIndex <- the tile index;
        container.on('mousedown', function(component, evt) {
          // I.
          component.set('_isBeingSelected', true);
          component.set('_startSelectSelectedIndex', this._intervalIndex);
        }.bind(container, this));

        // On mouse up
        // I. If we are currently selecting some tiles & the tile is the same as the start tile
        // I.1. _isBeingSelected <- false; _startSelectSelectedIndex & _endSelectSelectedIndex <- the tile index
        // I.2. Set the tile to _selected, and all the others to not selected. Fill with right color.
        // I.3. Calls _intervalSelectSelected;
        container.on('mouseup', function(component, evt) {
          // I.
          if(component._isBeingSelected && this._intervalIndex === component._startSelectSelectedIndex){
            // I.1.
            component.set('_isBeingSelected'       , false);
            this.removeChildren();
            // TODO: set behavior on the selection on ONE interval....
          }
        }.bind(container, this));

        // On mouse up outside
        // I. If we're currently selecting and the tile is not the same as the start tile.
        // I.1. _isBeingSelected <- false
        // I.2. If we didn't leave outside the tiles
        // I.2.1. We reorder the start and end (if user goes from right to left)
        // I.2.2. For each tile, we set as selected those who are between the first and last tile selected. We also fill with right color.
        // I.2.3. We call _intervalSelectSelected;
        // I.3 IF we leave outside the tiles, we reset the tiles with previous selected colors.
        container.on('mouseupoutside', function(component, evt) {
          // I.
          if(component._isBeingSelected && this._intervalIndex === component._startSelectSelectedIndex){
            // I.1.
            component.set('_isBeingSelected', false);
            var l = component._selectContainers;
            var i = 0;
            // I.2.
            if( component._lastHoverSelectIndex !== component._lastLeaveSelectIndex || component._lastHoverTime > component._lastLeaveTime  ){
              // I.2.1.
              if(component._lastHoverSelectIndex < component._startSelectSelectedIndex){
                component.set('_endSelectSelectedIndex', component.get('_startSelectSelectedIndex'));
                component.set('_startSelectSelectedIndex', component._lastHoverSelectIndex);
              }
              else{component.set('_endSelectSelectedIndex', component._lastHoverSelectIndex);}
              // I.2.2.
              var s = component._startSelectSelectedIndex;
              var e = component._endSelectSelectedIndex;
              var is = [];
              for(i = 0; i < l.length; i++){
                if( i >= s && i <= e){
                  component._fillSelectedContainer(l[i].c);
                  is.push(l[i]);
                }
                else{
                  l[i].c.removeChildren();
                }
              }
              // I.2.3.
              component._intervalSelectSelected(is);
            }
            // I.3.
            else{
              for(i = 0; i < l.length; i++){
                l[i].c.removeChildren();
              }
            }
          }
        }.bind(container, this));
        return container;
      },

    });
  </script>
</dom-module>
