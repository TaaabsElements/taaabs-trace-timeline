<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../pixi-js-component/pixi-js-component.html">
<dom-module id="taaabs-trace-timeline">
  <style>
    :host {
      display: block;
    }

    :host #pixijs {
      width: 100%;
    }
  </style>

  <template>
    <pixi-js-component id="pixijs" flex-width></pixi-js-component>
  </template>

  <script>
    Polymer({
      is: 'taaabs-trace-timeline',

      /**
       * Fired if the `begin` slider of the ZoomLine has been moved.
       * Fired when mouseup.
       *
       * @event zlBeginMoved
       */

      /**
       * Fired if the `end` slider of the ZoomLine has been moved.
       * Fired when mouseup.
       *
       * @event zlEndMoved
       */

      /**
       * Fired if the whole slider of the ZoomLine has been moved.
       * Fired when mouseup.
       *
       * @event zlGlobalMoved
       */

      properties: {

        /**
         * True, uses an OpenGL renderer.
         * False, uses a simple canvas.
         *
         * @attribute openGl
         * @type Boolean
         */
        openGl: {
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * Width of the pixijs component.
         *
         * @attribute _width
         * @type Number
         */
        _width: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * The list of obsels to display.
         *
         * @attribute obsels
         * @type Array
         */
        obsels: {
          type: Array,
          notify: true,
          value: function() {
            return [];
          }
        },

        /**
         * Begin time of the trace.
         *
         * @attribute begin
         * @type Number
         */
        begin: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * End time of the trace.
         *
         * @attribute end
         * @type Number
         */
        end: {
          type: Number,
          notify: true,
          value: 0
        },

        /**
         * Template for the shape of each obsel.
         *
         * @attribute styleTemplate
         * @type Object
         */
        styleTemplate: {
          type: String,
          notify: true,
          value: null,
          observer: '_createStyleArray'
        },

        /**
         * The list of obsels currently displayed.
         *
         * @attribute _obselsDisplayed
         * @type Array
         */
        _obselsDisplayed: {
          type: Array,
          notify: true,
          value: function() {
            return [];
          }
        },

        /**
         * True if the user clicks on an obsel.
         *
         * @attribute _clickOnObsel
         * @type Boolean
         */
        _clickOnObsel: {
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * List of graduations.
         * This array purpose is to get the graduation from a taaabs-trace-timeline-scroller.
         *
         * @attribute grad
         * @type Array
         */
        grad: {
          type: Array,
          notify: true,
          value: []
        }
      },

      listeners: {},

      ready: function() {},

      /**
       * Change `_width` according to the pixi width.
       *
       * @method _onPixiJsResize
       */
      _onPixiJsResize: function() {
        this.async(function(evt) {
          this.set('_width', this.$.pixijs.clientWidth);
          this.updateVisu();
        }.bind(this), 500);
      },

      /**
       * Return the width of the pixijs component (in pixels).
       *
       * @method _getWidth
       */
      _getWidth: function() {
        return this._width;
      },

      /**
       * Return the height of the visu.
       *
       * @method _getHeight
       */
      _getHeight: function() {
        return 215;
      },

      /**
       * Initialize the visualization.
       *
       * @method initVisu
       */
      initVisu: function() {
        this.$.pixijs.set('height', this._getHeight());
        this.$.pixijs.init({
          antialias: true
        });
        // Listen to pixi resize.
        this.listen(this.$.pixijs, 'iron-resize', '_onPixiJsResize');
        this.set('_width', this.$.pixijs.clientWidth);

        this._initZoomArea();
        this._initZoomFocusArea();

        for (var i = 0; i < Math.floor(this._getWidth() / 10); i++) {
          this.push('grad', this.$.pixijs.createRectangleFill(-1, 0, 2, this._getHeight(), 0xDADFE1));
          this.grad[i].z = 0;
          this.$.pixijs.addToStage(this.grad[i]);
        }
      },

      updateVisu: function() {
        this.$.pixijs.clearStage();
        this._initZoomArea();
        this._initZoomFocusArea();
        for (var i = 0; i < Math.floor(this._getWidth() / 10); i++) {
          this.push('grad', this.$.pixijs.createRectangleFill(-1, 0, 2, this._getHeight(), 0xDADFE1));
          this.grad[i].z = -1;
          this.$.pixijs.addToStage(this.grad[i]);
        }
        var obsels = [];
        this.set('_obselsDisplayed', []);
        this.displayObsels(this._begin, this._end, this.obsels);
      },

      /**
       * Initialize the zoom area and its events.
       *
       * @method _initZoomArea
       */
      _initZoomArea: function() {
        this.set('_zoomArea', this.$.pixijs.createRectangleFill(0, 0, this._getWidth(), this._getHeight(), 0xffffff));
        this._zoomArea.interactive = true;
        // Pointer on this
        var that = this;
        this._zoomArea.on('mousedown', function(event) {
          this.data = event.data;
          this.dragging = true;
          this._deltaPos = this.data.getLocalPosition(this.parent).x - this.position.x;
          that._zoomFocusArea.position.x = this.data.getLocalPosition(this.parent).x - 10;
          if (that._zoomFocusArea.position.x < 0) that._zoomFocusArea.position.x = 0;
        });

        this._zoomArea.on('mousemove', function() {
          if (this.dragging && !that._clickOnObsel) {
            that._zoomFocusArea.width = this.data.getLocalPosition(this.parent).x - that._zoomFocusArea.position.x;
          }
        });
        this._zoomArea.on('mouseup', function() {
          if (this.dragging && !that._clickOnObsel) {
            this.dragging = false;
            that._zoomFocusArea.width = this.data.getLocalPosition(this.parent).x - that._zoomFocusArea.position.x;

            if (that._zoomFocusArea.width < 0) {
              var posB = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              if (posB < 0)
                posB = 0;
              var posE = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            } else if (that._zoomFocusArea.width > 0) {
              var posE = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              var posB = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            }

          }
        });
        this._zoomArea.on('mouseupoutside', function() {
          if (this.dragging) {
            this.dragging = false;
            that._zoomFocusArea.width = this.data.getLocalPosition(this.parent).x - that._zoomFocusArea.position.x;

            if (that._zoomFocusArea.width < 0) {
              var posB = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              if (posB < 0)
                posB = 0;
              var posE = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            } else if (that._zoomFocusArea.width > 0) {
              var posE = that._zoomFocusArea.position.x + that._zoomFocusArea.width - 10;
              var posB = that._zoomFocusArea.position.x - 10;
              that._zoomBegin = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posB - 0) + that._begin);
              that._zoomEnd = Math.floor((that._end - that._begin) / (that._getWidth() - 20) * (posE - 0) + that._begin);
              that._zoomFocusArea.width = 0;
              that.fire('zoom');
            }
          }
        });

        this.$.pixijs.addToStage(this._zoomArea);
      },

      /**
       * Initialize the zoom focus area and its events.
       *
       * @method _initZoomFocusArea
       */
      _initZoomFocusArea: function() {
        this._zoomFocusArea = this.$.pixijs.createRectangleFill(0, 0, 1, this._getHeight(), 0x4183D7);
        this.$.pixijs.setParameters(this._zoomFocusArea, {
          'alpha': 0.5
        });
        this.$.pixijs.addToStage(this._zoomFocusArea);
      },

      /**
       * Returns a `Pixi.Graphics` object with the shape and color of an obsel.
       *
       * @param {!required} obsel (Object) The obsel to display.
       * @param {!required} size (Number) The size in pixel.
       * @param {!required} position (Pixi.Point) The position of the obsel.
       *
       * @method _getObselShape
       */
      _getObselShape: function(obsel, size, position) {
        // If there's no default style tempalte, we display every obsel as a blue square.
        if (this.styleTemplate === null || this.styleTemplate.rules.length === 0) {
          var gic = new this.$.pixijs.GraphicIC();
          gic.setPosition(position.x, position.y);
          gic.drawShape('SQUARE', size - 1, size - 1, 0x22A7F0);
          return gic;
        } else {
          // We get the rules of the styleTemplate;
          var rules = this.styleTemplate.rules;
          // A pointer on the most corresponding rule of an obsel.
          var directive = {};
          // We look for the most corresponding rule.
          for (var i = rules.length - 1; i >= 0; i--) {
            // True if the rule match the obsel (or is it the opposite?)
            var isInRange = true;
            // If the rule is on a type, we check if it ocrrespond to the type of our obsel
            if (rules[i].typeObsel)
              if (rules[i].typeObsel.name !== obsel['@type'])
                isInRange = false;
              // Now we check the attributes
            var j = 0;
            while (isInRange && rules[i].attributes && j < rules[i].attributes.length) {
              // If the obsel actually possess the attribute of the rule, we check for the operators of the rule
              if (obsel[rules[i].attributes[j].name]) {
                if (rules[i].attributes[j].operator) {
                  var attrVal = Number(obsel[rules[i].attributes[j].name]);
                  var styleVal = Number(rules[i].attributes[j].val);
                  if (isNaN(attrVal))
                    isInRange = false;
                  else {
                    switch (rules[i].attributes[j].operator) {
                      case '>':
                        if (attrVal <= styleVal)
                          isInRange = false;
                        break;
                      case '>=':
                        if (attrVal < styleVal)
                          isInRange = false;
                        break;
                      case '<':
                        if (attrVal >= styleVal)
                          isInRange = false;
                        break;
                      case '<=':
                        if (attrVal > styleVal)
                          isInRange = false;
                        break;
                    }
                  }
                } else {
                  if (obsel[rules[i].attributes[j].name] !== rules[i].attributes[j].val)
                    isInRange = false;
                }
              } else {
                isInRange = false;
              }
              j++;
            }
            if (isInRange) {
              if (Object.keys(directive).length === 0) {
                directive = rules[i];
              } else {
                var weight = 0;

                if (directive.typeObsel)
                  weight += 1;
                if (rules[i].typeObsel)
                  weight -= 1;
                if (rules[i].attributes && rules[i].attributes.length > directive.attributes.length + weight)
                  directive = rules[i];
              }
            }

            if (rules[i].type === "DEFAULT_GLOBAL_SYMBOL" && Object.keys(directive).length === 0)
              directive = rules[i];
          }

          if (Object.keys(directive).length === 0 || !directive.enabled)
            return null;

          var color = parseInt(directive.symbol.color.replace(/^#/, ''), 16);
          var gic = null;
          switch (directive.symbol.shape) {
            case 'SQUARE':
              gic = new this.$.pixijs.GraphicIC();
              gic.setPosition(position.x, position.y);
              gic.drawShape('SQUARE', size - 1, size - 1, color);
              return gic;
            case 'CIRCLE':
              gic = new this.$.pixijs.GraphicIC();
              gic.setPosition(position.x, position.y);
              gic.drawShape('CIRCLE', size, size, color);
              return gic;
            case 'DIAMOND':
              gic = new this.$.pixijs.GraphicIC();
              gic.setPosition(position.x, position.y);
              gic.drawShape('DIAMOND', size, size, color);
              return gic;
            case 'STAR':
              gic = new this.$.pixijs.GraphicIC();
              gic.setPosition(position.x, position.y);
              gic.drawShape('STAR', size, size, color);
              return gic;
            default:
              return this._getImage(size, position, directive.symbol.img);
          }

        }
      },

      /**
       * Displays a list of obsels, between a 'begin' & 'end'.
       *
       * @param {!required} start (Object) The beginning of the interval to display.
       * @param {!required} end (Number) The end of the interval to display.
       * @param {!required} obsels (Array) An array of obsels.
       *
       * @method displayObsels
       */
      displayObsels: function(start, end, obsels) {

        var that = this;

        this._begin = start;
        this._end = end;

        var d = new Date(start);

        d = new Date(end);

        // The size of the obsels (10px if there's more than 50 obsels, 20px otherwise)
        var obselSize = 0;

        // We remove the previous obsels drew
        for (var i = 0; i < this._obselsDisplayed.length; i++) {
          for (var j = 0; j < this._obselsDisplayed[i].length; j++) {
            this.$.pixijs.removeChildFromStage(this._obselsDisplayed[i][j]);
          }
        }

        // A list of list of obsels.
        // Each list represent an interval, for 10 or 20 obsels to be displayed.
        this.set('_obselsDisplayed', []);

        // If we have less then 50 obsels, we draw big obsels on 50 intervals.
        // Otherwise, we draw small obsels on 100 intervals.

        for (var i = 0; i < Math.floor(this._getWidth() / 10); i++) {
          this._obselsDisplayed.push([]);
        }
        obselSize = 10;

        // For each obsels, we stack them on their corresponding intervals.
        for (var i = 0; i < obsels.length; i++) {

          // X = (Position.end - Position.begin)/ (Time.end - Time.begin) * (Time - Time.begin) + Position.begin;
          // TODO changement de la position des obsels
          var pixelPos = ((this._getWidth() - 20 - 0) / (end - start)) * (obsels[i].end - start) + 0;
          //var pixelPos = ( (1000 - 0) / (end - start) ) * ( obsels[i].end - start ) + 0;

          // The index of the interval in 'obsels'.
          var arrayPos = Math.floor(pixelPos / obselSize);

          var max = 20;

          // If we still got room in a stack.
          if (this._obselsDisplayed[arrayPos].length < max) {

            var posy = 0;
            posy = 200 - (obselSize + 1) * this._obselsDisplayed[arrayPos].length;

            var obs = this._getObselShape(obsels[i],
              obselSize,
              new PIXI.Point(arrayPos * obselSize + 5, posy));

            if (obs !== null) {
              obs.g.interactive = true;
              obs.g.buttonMode = true;
              obs.g.obsel = obsels[i];

              obs.g.on('mouseover', function(obs, evt) {
                  obs.setStroke(1, 0x000000);
                  obs.scale(1);
                  this.$.pixijs.removeChildFromStage(obs.c);
                  this.$.pixijs.addToStage(obs.c);
                }.bind(this, obs))
                .on('mouseout', function(obs, evt) {
                  obs.scale(-1);
                  this.$.pixijs.removeChildFromStage(obs.c);
                  this.$.pixijs.addToStage(obs.c);
                  obs.setStroke(0, 0x000000);
                  //if (!this._clickOnObsel && !evt.target.clicked) this._deEmphasizeObsel(evt.target);
                }.bind(this, obs))
                .on('mousedown', function() {
                  that._clickOnObsel = true;
                })
                .on('mouseup', function(evt) {
                  that._clickOnObsel = false;
                  that.fire('obselClicked', {
                    "obs": evt.target.obsel
                  });
                }.bind(this))
                .on('mouseupoutside', function() {
                  that._clickOnObsel = false;
                });

              this.$.pixijs.addToStage(obs.c);

              this._obselsDisplayed[arrayPos].push(obs);
            }
          }
        }
      }

    });
  </script>
</dom-module>
